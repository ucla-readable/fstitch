
OBJDIRS += fs

FSIMGFILES :=		fs/.journal \
			fs/404.html \
			fs/bomb.img \
			fs/dev \
			fs/favicon.ico \
			fs/goomba.spr \
			fs/index.html \
			fs/init.sh \
			fs/k0 \
			fs/k1 \
			fs/k2 \
			fs/kbear.jpg \
			fs/kfsgraphviz.sh \
			fs/lady.img \
			fs/lady.jpeg \
			fs/lady.pal \
			fs/lorem \
			fs/mario.pal \
			fs/mario.spr \
			fs/motd

-include fs/audio/Makefrag
FSIMGFILES := $(FSIMGFILES) $(FSIMGTXTFILES)

include conf/fs.mk
ifndef FSSIZE
	FSINUSE := \`du -slLc --block-size=4096 $(FSIMGFILES) | grep total$$ | awk '{print $$1}'\`
	FSSIZE := `echo $$((($(FSINUSE) + 255) / 256 + $(FSFREE)))`
endif

$(OBJDIR)/fs/clean-fs.img: $(UTILDIR)/$(FSFORMAT) $(FSIMGFILES)
	@echo + mk $(OBJDIR)/fs/clean-fs.img \($(FSSIZE)M\)
	$(V)mkdir -p $(@D)
	$(V)dd if=/dev/zero of=$(OBJDIR)/fs/clean-fs.img bs=1M count=$(FSSIZE) 2>/dev/null
	$(V)$(UTILDIR)/$(FSFORMAT) $(OBJDIR)/fs/clean-fs.img $(FSIMGFILES)

$(OBJDIR)/fs/fs.img: $(OBJDIR)/boot/mbr $(OBJDIR)/fs/clean-fs.img
	@echo + mk $(OBJDIR)/fs/fs.img
	$(V)cp $(OBJDIR)/boot/mbr $@
	$(V)dd if=$(OBJDIR)/fs/clean-fs.img of=$@ seek=1 conv=notrunc 2> /dev/null

# ufs.img is largely a sparse file.
# Use GNU cp to create ufs.img and let the OS know about its holes:
$(OBJDIR)/fs/ufs.img: fs/ufs-clean.img.gz
	@echo + mk $(OBJDIR)/fs/ufs.img
	$(V)[ ! -f $(OBJDIR)/fs/ufs.img.fifo ] || rm -f $(OBJDIR)/fs/ufs.img.fifo
	$(V)mkfifo $(OBJDIR)/fs/ufs.img.fifo
	$(V)gunzip -c fs/ufs-clean.img.gz > $(OBJDIR)/fs/ufs.img.fifo &
	$(V)cp --sparse=always $(OBJDIR)/fs/ufs.img.fifo $(OBJDIR)/fs/ufs.img
	$(V)rm -f $(OBJDIR)/fs/ufs.img.fifo

fs/.journal:
	@echo + dd if=/dev/zero of=fs/.journal
	$(V)dd if=/dev/zero of=fs/.journal bs=1M count=4 2>/dev/null

fs/dev fs/k0 fs/k1 fs/k2:
	$(V)mkdir $@

all: $(OBJDIR)/fs/fs.img
