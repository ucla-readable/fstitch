#
# Makefile fragment for KudOS kernel.
# This is NOT a complete makefile;
# you must run GNU make in the top-level directory
# where the GNUmakefile is located.
#

OBJDIRS += kern

KERN_LDFLAGS := $(LDFLAGS) -T $(OBJDIR)/kern/kernel.ld -nostdlib


INIT=init
ENV=env
PMAP=pmap

# entry.S must be first, so that it's the 
# first code in the text segment!!!
#
# Note that we also snatch the use of a couple handy source files
# from the lib directory, to avoid gratuitous code duplication.
KERN_SRCFILES :=	kern/entry.S \
			kern/$(INIT).c \
			kern/console.c \
			kern/monitor.c \
			kern/breakpoints.c \
			kern/elf.c \
			kern/stabs.c \
			kern/$(PMAP).c \
			kern/$(ENV).c \
			kern/kclock.c \
			kern/picirq.c \
			kern/irq.c \
			kern/pci.c \
			kern/mouse.c \
			kern/printf.c \
			lib/serial.c \
			kern/trap.c \
			kern/trapentry.S \
			kern/sched.c \
			kern/syscall.c \
			kern/sb16.c \
			kern/vga.c \
			kern/josnic.c \
			kern/3c509.c \
			kern/8390.c \
			kern/ne.c \
			kern/version.c \
			lib/printfmt.c \
			lib/readline.c \
			lib/string.c

# Only build files if they exist.
KERN_SRCFILES := $(wildcard $(KERN_SRCFILES))

# Binary program images to embed within the kernel.
KERN_BINFILES :=	user/idle \
			user/initsh \
			user/init \
			user/netd \
			kfs/kfsd

KERN_SRCFILES +=	kern/appkernbin.c

KERN_OBJFILES := $(patsubst %.c, $(OBJDIR)/%.o, $(KERN_SRCFILES))
KERN_OBJFILES := $(patsubst %.S, $(OBJDIR)/%.o, $(KERN_OBJFILES))
KERN_OBJFILES := $(patsubst obj/kudos/lib/%, obj/kudos/kern/%, $(KERN_OBJFILES))

KERN_BINFILES := $(patsubst %, $(OBJDIR)/%, $(KERN_BINFILES))

# Make sure version.c is recompiled every time the kernel is built
$(OBJDIR)/kern/version.o: $(KERN_SRCFILES) $(KERN_BINFILES)

# How to build the kernel itself
$(OBJDIR)/kern/kernel: $(KERN_OBJFILES) $(KERN_BINFILES) $(OBJDIR)/kern/kernel.ld $(UTILDIR)/$(ELFDUMP_SYMTAB)
	@echo + ld $@
	$(V)echo "" > $(SYMTBL)
	$(V)echo "" > $(SYMSTRTBL)
	$(V)$(LD) -o $@ $(KERN_LDFLAGS) $(KERN_OBJFILES) $(GCC_LIB) -b binary $(KERN_BINFILES) $(SYMTBL) $(SYMSTRTBL)
	$(V)$(UTILDIR)/$(ELFDUMP_SYMTAB) -sym $@ > $(SYMTBL)
	$(V)$(UTILDIR)/$(ELFDUMP_SYMTAB) -symstr $@ > $(SYMSTRTBL)
	$(V)# We assume here that running ld this second time does not change what
	$(V)# the elf symtable/strtable holds. TODO: is this a safe assumption?
	$(V)$(LD) -o $@ $(KERN_LDFLAGS) $(KERN_OBJFILES) $(GCC_LIB) -b binary $(KERN_BINFILES) $(SYMTBL) $(SYMSTRTBL)
	$(V)rm -f $(SYMTBL) $(SYMSTRTBL)
	$(V)$(OBJDUMP) -S $@ > $@.asm
	$(V)$(NM) -n $@ > $@.sym
	$(V)$(STRIP) $@

# How to build the Bochs disk image
$(OBJDIR)/kern/bochs.img: $(OBJDIR)/kern/kernel $(OBJDIR)/boot/boot $(OBJDIR)/boot/stage2
	@echo + mk $@
	$(V)dd if=/dev/zero of=$(OBJDIR)/kern/bochs.img~ count=10000 2>/dev/null
	$(V)dd if=$(OBJDIR)/boot/boot of=$(OBJDIR)/kern/bochs.img~ conv=notrunc 2>/dev/null
	$(V)dd if=$(OBJDIR)/boot/stage2 of=$(OBJDIR)/kern/bochs.img~ seek=1 count=7 conv=notrunc 2>/dev/null
	$(V)dd if=$(OBJDIR)/kern/kernel of=$(OBJDIR)/kern/bochs.img~ seek=8 conv=notrunc 2>/dev/null
	$(V)mv $(OBJDIR)/kern/bochs.img~ $(OBJDIR)/kern/bochs.img

all: $(OBJDIR)/kern/bochs.img

grub: $(OBJDIR)/kudos-grub

$(OBJDIR)/kudos-grub: $(OBJDIR)/kern/kernel
	@echo + oc $@
	$(V)$(OBJCOPY) --adjust-vma=0x10000000 $^ $@

# How to build the kernbin structures
kern/appkernbin.c: kern/KMakefrag
	@echo + mk $@
	$(V)echo '#include <kern/kernbin.h>' >$@
	$(V)echo $(KERN_BINFILES) | tr ' ' '\012' | grep . | sed 's/obj\/kudos\/\([^\/]*\)\/\(.*\)/extern const uint8_t _binary_obj_kudos_\1_\2_start[], _binary_obj_kudos_\1_\2_size[];/' >>$@
	$(V)echo 'struct Kernbin kernbins[] = {' >>$@
	$(V)echo $(KERN_BINFILES) | tr ' ' '\012' | grep . | sort | sed 's/obj\/kudos\/\([^\/]*\)\/\(.*\)/{ "\2", _binary_obj_kudos_\1_\2_start, (int)_binary_obj_kudos_\1_\2_size },/' >>$@
	$(V)echo "{ 0, 0, 0 } };" >>$@
